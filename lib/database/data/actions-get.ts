import { RowDataPacket } from 'mysql2/promise';

import pool from '../conn';
import { timeStampGen } from '../../../lib/helpers';
import type { ActiveChallenge, DailyData, DailyUserStats, UserData } from '@/types';

const formatTime = (isoString: string): string => {
    if(isoString === 'no-time') {
        return '-';
    }
    const date = new Date(isoString);

    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
   
    return `${hours}:${minutes} Ñ‡.`;
};

const sortUsersByTime = (users: UserData[]): UserData[] => {
    return users.sort((a, b) => {
        const timeA = new Date(a.time);
        const timeB = new Date(b.time);
        return timeA.getTime() - timeB.getTime();
    });
};

export const getActiveChallenge = async (): Promise<ActiveChallenge | null>  => {
    const poolConn = await pool.getConnection();
    try {
        const [rows] = await poolConn.query<RowDataPacket[]>('SELECT id, name, feature FROM challenges WHERE status = "active"');
        if (rows.length > 0) {
            return {
                id: rows[0].id,
                name: rows[0].name,
                feature: rows[0].feature

            };
        }

        return null;

    } catch (error) {
        console.error(`${timeStampGen()} Error generated by func getActiveChallenge: ${error}`);
        return null;
    } finally {
        poolConn.release();
    };
}

export const getActiveFeature = async (): Promise<ActiveChallenge['feature'] | null>  => {
    const poolConn = await pool.getConnection();
    try {
        const [rows] = await poolConn.query<RowDataPacket[]>('SELECT id, name, feature FROM challenges WHERE status = "active"');
        if (rows.length > 0) {

            const [result] = await poolConn.query<RowDataPacket[]>(`SELECT * FROM \`daily-stats\` WHERE challenge_id = ? AND locked = 'no'`, [rows[0].id]);

            if (result.length > 0) {
                return result[0] as ActiveChallenge['feature']
            } else {
                return null
            }
        }

        return null;

    } catch (error) {
        console.error(`${timeStampGen()} Error generated by func getActiveFeature: ${error}`);
        return null;
    } finally {
        poolConn.release();
    };
}

export const getDailyStats = async (userId: number): Promise<DailyUserStats | null> => {
    const poolConn = await pool.getConnection();
    try {

        const query = `
                SELECT 
                    ds.indexNum, uds.id as daily_field, uds.finished, uds.note, uds.count
                FROM \`daily-stats\` AS ds
                LEFT JOIN \`user-daily-stats\` AS uds ON ds.id = uds.daily_stats_id
                WHERE uds.user_id = ? AND ds.locked = 'no'
                `

        const [rows] = await poolConn.query<RowDataPacket[]>(query, [userId]);
        if (rows.length > 0) {
            return rows[0] as DailyUserStats
        }

        return null

    } catch (error) {
        console.error(`${timeStampGen()} Error generated by func getDailyStats: ${error}`);
        return null;
    } finally {
        poolConn.release();
    };
}

export const getTotalStats = async (): Promise<DailyData[] | null> => {
    const poolConn = await pool.getConnection();
    try {

        const query = `
                SELECT 
                    uds.daily_stats_id as day, uds.note, uds.finished, uds.completed_at as time, uds.user_id as userId, uds.count, ut.username, ut.avatar
                FROM \`user-daily-stats\` AS uds
                LEFT JOIN \`users\` AS ut ON uds.user_id = ut.id
                `

        const [rows] = await poolConn.query<RowDataPacket[]>(query);
        if (rows.length > 0) {
            const dailyData: DailyData[] = rows.reduce((acc: DailyData[], row: RowDataPacket) => {
                let dayObj = acc.find(d => d.day === row.day);
                if (!dayObj) {
                    dayObj = { day: row.day, users: [] };
                    acc.push(dayObj);
                }

                dayObj.users.push({
                    userId: row.userId,
                    username: row.username,
                    finished: row.finished,
                    time: row.time, 
                    avatar: row.avatar,
                    note: row.note,
                    count: row.count
                });

                return acc;
            }, []).map(day => ({
                ...day,
                users: sortUsersByTime(day.users)
            }));

            return dailyData.map(day => ({
                ...day,
                users: day.users.map(user => ({
                    ...user,
                    time: user.finished === "yes" ? formatTime(user.time) : formatTime('no-time')
                }))
            }));
        }

        return null

    } catch (error) {
        console.error(`${timeStampGen()} Error generated by func getDailyStats: ${error}`);
        return null;
    } finally {
        poolConn.release();
    };
}